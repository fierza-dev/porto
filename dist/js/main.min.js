// Configuration
const CONFIG = {
    basePath: '/',
    components: {
        header: 'component/header.html',
        navbar: 'component/navbar.html',
        hero: 'includes/hero.html',
        about: 'includes/about.html',
        service: 'includes/service.html',
        project: 'includes/project.html',
        contact: 'includes/contact.html',
        footer: 'component/footer.html'
    },
    loadPriority: ['navbar', 'hero', 'header', 'footer', 'about', 'service', 'project', 'contact'],
    timeout: 8000
};

// Utility functions
const waitForDependencies = async () => {
    const maxAttempts = 10;
    let attempts = 0;
    
    return new Promise((resolve, reject) => {
        const check = () => {
            attempts++;
            if (typeof AOS !== 'undefined' && typeof HSStaticMethods !== 'undefined') {
                resolve();
            } else if (attempts >= maxAttempts) {
                reject(new Error('Dependencies not loaded after maximum attempts'));
            } else {
                setTimeout(check, 300);
            }
        };
        check();
    });
};

const loadComponent = async (id, path) => {
    try {
        const element = document.getElementById(id);
        if (!element) {
            console.warn(`Element ${id} not found`);
            return false;
        }

        const fullPath = `${CONFIG.basePath}${path}`;
        const response = await fetch(fullPath);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status} - ${response.statusText}`);
        }

        const html = await response.text();
        element.innerHTML = html;
        
        // Process scripts safely
        const scripts = element.querySelectorAll('script');
        scripts.forEach(script => {
            const newScript = document.createElement('script');
            [...script.attributes].forEach(attr => {
                newScript.setAttribute(attr.name, attr.value);
            });
            newScript.textContent = script.textContent;
            script.replaceWith(newScript);
        });

        return true;
    } catch (error) {
        console.error(`Failed to load ${path}:`, error);
        const element = document.getElementById(id);
        return false;
    }
};

// Main initialization
const initializeApp = async () => {
    try {
        // Initialize AOS after dependencies are loaded
        await waitForDependencies();
        AOS.init({
            duration: 800,
            easing: 'ease-in-out',
            once: true,
            initClassName: 'aos-init',
            disable: window.matchMedia('(prefers-reduced-motion: reduce)').matches
        });

        // Load components in priority order
        for (const componentId of CONFIG.loadPriority) {
            if (CONFIG.components[componentId]) {
                await loadComponent(componentId, CONFIG.components[componentId]);
            }
        }

        // Initialize Preline components
        if (typeof HSStaticMethods !== 'undefined') {
            HSStaticMethods.autoInit();
        }

        // Hide loading screen
        const loadingElement = document.getElementById('app-loading');
        if (loadingElement) {
            loadingElement.style.opacity = '0';
            setTimeout(() => {
                loadingElement.remove();
            }, 300);
        }
    } catch (error) {
        console.error('Application initialization failed:', error);
        const loadingElement = document.getElementById('app-loading');
        if (loadingElement) {
            loadingElement.innerHTML = `
                <div class="text-center p-6 bg-white rounded-lg shadow">
                    <h3 class="text-xl font-bold text-red-600 mb-2">Initialization Error</h3>
                    <p class="mb-4">${error.message}</p>
                    <button onclick="window.location.reload()" 
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Reload Page
                    </button>
                </div>
            `;
        }
    }
};

// Start the application
document.addEventListener('DOMContentLoaded', () => {
            const confettiTrigger = document.querySelector('#hs-run-on-click-run-confetti');

            if (!confettiTrigger) return;

            // Configuration object for easy customization
            const config = {
                duration: 15000, // 15 seconds in milliseconds
                defaults: {
                    startVelocity: 30,
                    spread: 360,
                    ticks: 60,
                    zIndex: 0,
                    colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'] // Added colors
                },
                interval: 250, // milliseconds between bursts
                particleMultiplier: 50
            };

            // Cache start time and calculate end time
            let animationEnd;
            let intervalId;
            let isRunning = false;

            // Improved random number generator
            const randomInRange = (min, max) => Math.random() * (max - min) + min;

            const startConfetti = () => {
                if (isRunning) return;

                isRunning = true;
                animationEnd = Date.now() + config.duration;

                intervalId = setInterval(() => {
                    const timeLeft = animationEnd - Date.now();

                    if (timeLeft <= 0) {
                        stopConfetti();
                        return;
                    }

                    // Calculate particle count based on time left
                    const particleCount = config.particleMultiplier * (timeLeft / config.duration);

                    // Left side confetti
                    confetti({
                        ...config.defaults,
                        particleCount,
                        origin: {
                            x: randomInRange(0.1, 0.3),
                            y: Math.random() - 0.2
                        }
                    });

                    // Right side confetti
                    confetti({
                        ...config.defaults,
                        particleCount,
                        origin: {
                            x: randomInRange(0.7, 0.9),
                            y: Math.random() - 0.2
                        }
                    });
                }, config.interval);
            };

            const stopConfetti = () => {
                clearInterval(intervalId);
                isRunning = false;
                // Optional: Clear all confetti particles immediately
                confetti.reset();
            };

            // Add event listener with cleanup
            confettiTrigger.addEventListener('click', startConfetti);

            // Cleanup function if needed
            window.cleanupConfetti = stopConfetti;
        });
